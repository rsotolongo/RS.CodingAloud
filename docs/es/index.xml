<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programando en voz alta</title>
    <link>/es/</link>
    <description>Recent content on Programando en voz alta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Thu, 17 Dec 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/es/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>El futuro del Ensamblador</title>
      <link>/es/post/futuro-del-ensamblador/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/futuro-del-ensamblador/</guid>
      
        <description>&lt;p&gt;Si difícil fue en su tiempo programar en lenguaje de máquina, difícil fue también hacerlo en ensamblador, aunque todavía haya personas que no lo quieran reconocer. El lenguaje ensamblador constituyó un paso de adelanto indudable sobre su predecesor, pero no estaba extinto de problemas.&lt;/p&gt;
&lt;p&gt;Poco a poco fue tomando auge, pero a la vez fueron surgiendo nuevos lenguajes que se le superponían y a la vez acomodaban al programador. Esto no es más que parte de la lógica de la evolución de la programación. A medida que estos nuevos lenguajes iban tomando auge, a la vez otros nuevos se desarrollaban y así sucesivamente.
Hoy por hoy hay muchos profesionales que insisten en que los proyectos desarrollados en ensamblador son mejores que los que son desarrollados en lenguajes de alto nivel (Object Pascal, Java, C#, etc.) pues consumen menos espacio en disco, memoria cuando están ejecutándose y son extremadamente veloces. En cierta manera no es menos cierto lo que plantean, pero hay elementos que no tienen en cuenta. Con los estándares de desarrollo profesional de software del momento estos argumentos pierden importancia frente a otros como son (sobre todas las cosas) el tiempo de respuesta y completitud de los proyectos.&lt;/p&gt;
&lt;p&gt;Se hace insoportable el mantenimiento. La industria de software moderna exige cada vez más que las aplicaciones sean desarrolladas en tiempo record, cosa que es incomparable cuando se programa en ensamblador. En todos los casos me he referido a las aplicaciones empresariales tradicionales.&lt;/p&gt;
&lt;p&gt;El ensamblador está condenado hoy en día para el desarrollo de firmware a muy bajo nivel para los dispositivos empotrados, por ejemplo: sistemas operativos para dispositivos móviles, equipos médicos, de telecomunicaciones, etc. Un buen amigo me dijo hace ya unos años que el programa que por sus características propias tuviera que implementar alguno de sus módulos en ensamblador, ese programa estaba mal diseñado; comparto con mi amigo esa verdad (si eso fue hace unos años ¿qué podremos pensar hoy?). Los Plan de Estudios &amp;ldquo;D&amp;rdquo; tiene esto muy en mente también y todo parece ser que se seguirá impartiendo conocimientos de ensamblador, pero a los niveles diferentes a los que se estaban dando.&lt;/p&gt;
&lt;p&gt;El dilema está planteado por las características de las dos grandes plataformas de desarrollo de software actuales (Java y .NET) ninguna permite interactuar con el ensamblador, eliminándole al programador infinitas molestias. Si todo parece indicar que esto va a continuar en los próximos años entonces por qué torturarnos enseñando algo que poco a poco va a ir desapareciendo (Microsoft está llevando adelante un proyecto de un Sistema Operativo en C#).&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Fanatismos</title>
      <link>/es/post/fanatismos/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/fanatismos/</guid>
      
        <description>&lt;p&gt;Hay que ver que el ser humano, en su vano afán de querer tener siempre la razón, hace cosas increíbles. Una de ellas es aquella manía de empecinarse con algo (dígase objetos, conceptos, teorías, personas, etc.) que le hemos llamado fanatismo.&lt;/p&gt;
&lt;p&gt;¿Alguien podrá decir que no es fanático a nada? Creo que no, pues ¿quién no se obsesionó con su primer amor? Existen varios tipos de fanatismos, el que se profesa por los objetos materiales, la religión, los equipos deportivos, etc. Pero no es de esos tipos de fanatismo a los que quiero referirme, sino a un tipo especial y que nos toca muy de cerca a todos los que de alguna manera desarrollamos nuestras vidas vinculadas a la computación, me refiero al fanatismo tecnológico.
Sin dejar de asemejarse con otros fanatismos (al menos en sus esencias fundamentales), este es un poquito particular. Se puede ver aplicado en cualquier rama de la computación: filosofías, hardware, software, metodologías, sistemas operativos, servicios, servidores, etc. El más clásico y que ha tomado mucho auge en los últimos tiempos es aquel aplicado al software libre y al software propietario.&lt;/p&gt;
&lt;p&gt;¿Quién tiene la razón? ¿Quién ganará la guerra? se preguntarán muchos imparciales que pueden ver el fenómeno desde las gradas. Los que están en cada bando, evidentemente confían e intentan asegurarse que serán ellos los ganadores con toda la razón de su parte. Ahora bien, para aquellos que, sin estar en las gradas, pero tampoco directamente en ningún equipo (donde creo que actualmente estoy) la respuesta a esas inquietudes parece ser la más lógica.&lt;/p&gt;
&lt;p&gt;Realmente creo que ninguno ganará pues los dos bandos tienen razón en muchas cosas y solo dejan de tenerla en pequeñas asperezas del modelo. Si de todas formas tuviera que vaticinar un ganador diría que será el que mejor logre adaptarse a la forma de ver las cosas del otro; pero más aun, si tuviera que concretar diría que el software propietario es el que pudiera hacerlo si hace bien las cosas. Motivos por los cuales me decido a decirlo es porque en la actualidad cuenta con la inmensa mayoría de aplicaciones ya desarrolladas y con un altísimo nivel de penetración en el mundo completo, esto hace que las compañías tengan un gran capital para invertir en hacerse cada día mejores (cosa muy importante).&lt;/p&gt;
&lt;p&gt;¿Qué podría dar al traste con esta decisión? Que en vez de dedicarse a suavizar las licencias comerciales con las cuales se distribuyen sus productos, dediquen esfuerzos a atacar al bando contrario. El movimiento de software libre no se ha quedado con los brazos cruzados, pero tiene que cambiar radicalmente su forma de enfrentar las cosas. Aquellos que son seguidores de este movimiento no pueden ver, ni escuchar, ni tan siquiera imaginarse que lo que le estén mostrando o hablando &amp;ldquo;huela&amp;rdquo; a software propietario, porque ponen el plug a tierra y es como si no existiera la contraparte, es decir, solo lo de ellos es mejor y no tiene defectos algunos, es a esto precisamente a lo que me refiero. Que me disculpen los que no piensan así, pero en mi experiencia me ha tocado enfrentarme a muchas de estas personas.&lt;/p&gt;
&lt;p&gt;En un principio y como fanático al fin del software propietario me enfrascaba en la más tediosa discusión por defender lo que tenía dentro de mí, esto fue así hasta que desperté de ese sueño. Hace falta que muchos más despierten. Actualmente hago igual que cuando alguien intenta demostrarme que Dios creó el mundo (que me disculpen los creyentes), acordamos no hablar de ese tema y seguir conversando de lo hermosa que es la vida.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Herramientas para los blogs</title>
      <link>/es/post/herramientas-para-blogs/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/herramientas-para-blogs/</guid>
      
        <description>&lt;p&gt;No hay duda que la web revolucionó el mundo de la información a disposición de todos sus usuarios, pero por sus propias características tiene un gran inconveniente: sigue siendo el usuario el responsable de visitar expresamente los sitios de los que quiere nutrirse.&lt;/p&gt;
&lt;p&gt;Cuando se visitan dos o tres sitios o se hace con poca frecuencia esto no interesa mucho, sin embargo, cuando se requiere informarse apenas se publique la información esto se convierte en un problema.&lt;/p&gt;
&lt;p&gt;Es para ello que surgen los formatos de intercambio de informaciones RSS que no son más que ficheros XML que guardan, entre otras cosas, el encabezado de la información, el cuerpo, fecha, localización completa, entre otros campos. Este fichero de intercambio no es por gusto pues se brinda para que los usuarios necesitados de &amp;ldquo;estar en la última&amp;rdquo; utilicen un cliente al efecto. Dentro de los clientes más utilizados están el FeedReader y el RSSReader. Cada uno de ellos son capaces cada cierto tiempo de descargar los ficheros de los sitios que se tengan configurados y avisarles a los usuarios de las nuevas informaciones que hay publicadas con respecto a la vez anterior que se conectó.&lt;/p&gt;
&lt;p&gt;Básicamente ese es el funcionamiento de estas herramientas. Existen varios formatos de estos ficheros de intercambio, ya habíamos dicho los RSS, pero también existen los CDF, cada uno con más de una versión. Existe otro formato de fichero que es una reunificación de los dos anteriores que como toda reunificación se ha convertido en una tercera variante. Como la conversión de uno a otro no es cosa difícil (apenas aplicar una transformación XSLT) por lo general los sitios y portales que brindan estas posibilidades ofertan los tres tipos de ficheros.&lt;/p&gt;
&lt;p&gt;Son los blogs el tipo de sitio que más ha ayudado a proliferar estas tecnologías. Recordemos que los blogs se pueden ver como la versión digitalizada de un diario personal. Hoy por hoy constituyen precisamente los blogs la fuente número uno de publicaciones de científicos, programadores, filósofos, etc. En el mundo, todo profesional que se respeta tiene uno y sobre todas las cosas establece un compromiso para con sus suscriptores de mantenerlo actualizado constantemente.&lt;/p&gt;
&lt;p&gt;Microsoft comprendió rápidamente lo antes expuesto y le ha incorporado la posibilidad de RSS al Internet Explorer 7 que pronto saldrá al mercado. Por su parte existe una extensión para Mozilla Firefox que permite lo mismo. Poco a poco pienso que se hará más común su integración con los restantes navegadores de Internet.&lt;/p&gt;
&lt;p&gt;Yo comencé a utilizar el FeedReader apenas lo vi pues comprendí todo lo que podía ayudarme, al punto que lo instalé en las máquinas de los laboratorios docentes para que se utilizara. En mi máquina le configuré todos los sitios de los que asiduamente visito y más nunca tuve que ir a ellos a ver qué tenían de nuevo, el FeedReader cada cierto tiempo (por lo general una o dos horas) me avisaba. Luego de la reinstalación de los servidores en pos de insertarnos en RedUNIV se puso que la autentificación contra el proxy fuera integrada y ahí mismo dejó de funcionar esta útil herramienta, esperamos que en alguna versión superior tenga la posibilidad de autentificase por NTLM.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Borland Co.</title>
      <link>/es/post/borland/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/borland/</guid>
      
        <description>&lt;p&gt;Es increíble cómo las malas estrategias de negocio llevan a convertir a una empresa líder mundial en herramientas de desarrollo en una empresa de retaguardia tecnológica. Específicamente me refiero a Borland Company.&lt;/p&gt;
&lt;p&gt;Borland surgió allá por los lejanos años 80 como desarrolladora de los mejores compiladores del lenguaje Pascal y luego de sus ambientes de desarrollo Turbo Pascal (Microsoft en su momento lanzó en Microsoft Pascal que fue todo un fracaso). Ya desde la versión 3 se perfiló como una herramienta innovadora para su tiempo, pero no fue hasta la versión 5 que se consagró al permitir de manera integrada depurar errores. Apenas en la próxima versión (la 5.5) ya incorporaba al lenguaje el soporte (aunque muy rudimentario y con errores conceptuales) del nuevo paradigma de programación: la Orientación a Objetos. En esos tiempos no se conoció ningún marco de trabajo mejor que TurboVision para el desarrollo de aplicaciones con interfaces increíbles sobre MS-DOS, característica nueva en la versión 6. La versión 7 aportó pocas cosas nuevas, no siendo hasta la próxima que cambió de nombre el producto llamándose ahora Borland Pascal, cuya característica fundamental fue la posibilidad de acceso a la API de Windows y poder desarrollar aplicaciones con interfaces que usaban la GUI.&lt;/p&gt;
&lt;p&gt;Ahí terminó esa línea de productos y con ella los fondos de la compañía, hasta el punto que tuvieron que despedir a casi todo el personal y quedarse solo con una reducida cantidad de programadores. Ellos se encerraron durante casi dos años desarrollando un producto nuevo súper secreto que iba a revolucionar las herramientas de desarrollo de aplicaciones. No se equivocaron, ese producto fue Borland Delphi 1. Éxito total, increíble, magnífico, se acababan los elogios cuando se le describía.&lt;/p&gt;
&lt;p&gt;Luego fueron saliendo las próximas versiones que se pueden catalogar más de lo mismo, amén de raras excepciones. Si bien la versión 3 incorporó las funcionalidades de COM y descendientes, no fue hasta la versión 4 donde se hace un salto cualitativo. La versión 5 más de lo mismo al igual que la 6 y la 7. El factor común de todas las versiones fue la mejora de los componentes de la versión anterior y mejoras en el IDE.&lt;/p&gt;
&lt;p&gt;A medida que fueron afianzándose en el mercado fueron desarrollando casi a la par también herramientas sumamente parecidas con la diferencia del lenguaje de programación, así fue como surgió Borland C++ Builder y Java Builder. La respuesta de los programadores del mundo completo no se hizo esperar y en poco tiempo Borland contaba con la mayor comunidad de desarrolladores volcados sobre sus herramientas, por eso no es extraño todavía hoy en día encontrar que sea Delphi el ambiente de desarrollo para el cual existan la mayor cantidad de componentes disponibles.&lt;/p&gt;
&lt;p&gt;Si bien esto es cierto, Borland no supo cuidar de esa comunidad y de sus justos reclamos. Nunca sacó versiones de sus productos en un idioma que no fuera el inglés y mucho menos entonces documentación técnica de ellos en los idiomas reclamados. Cuando comenzaron a ver problemas financieros otra vez pensaron que con cambiarle en nombre a la compañía los solucionarían, todo lo contrario, a la comunidad no le gustó mucho que dejara de ser Borland para convertirse en Inprise (Delphi 5 y su XML). Microsoft no se quedó con los brazos cruzados y de alguna manera convenció a los principales programadores líderes para que se pasaran a sus líneas de investigación y consiguió desarticular Borland (pronto publicaré un artículo al respecto que hace ya algunos años redacté por necesidad).&lt;/p&gt;
&lt;p&gt;Si algo identificó siempre a los productos de Borland ese algo fueron los IDE, desde las antiguas versiones de Turbo Pascal no había ningún IDE que se le asemejara y mucho menos que compitiera con su editor de códigos. Incluso el Quick Editor (qe.exe) -todo un editor de textos profesional- compitiendo ahí, ahí con el de Turbo Pascal se las veía negras para ganarle. Esto poco a poco fue desapareciéndose en Borland, dejándose tomar la delantera estratégica por Microsoft y su gama de herramientas de desarrollo Visual Studio, sobre todo a partir de las versiones para la plataforma de desarrollo .NET.&lt;/p&gt;
&lt;p&gt;Cuando alguna compañía está en picada, es cierto que sus errores se ven más porque lejos de levantar lo que hace es hundirse más en los problemas. Kylix (Delphi para Linux) que constituyó todo un suceso en las herramientas de desarrollo profesional en Linux no supieron consagrarlo a pesar de no contar con rival en el área. Fueron capaces de desarrollar tres versiones del producto, pero todo fue en vano. A la borda dinero y esfuerzo otra vez.&lt;/p&gt;
&lt;p&gt;Ian Marteens, el ilustre escritor de la saga de libros &amp;ldquo;Mastering in Delphi X&amp;rdquo; ya promueve en un propio sitio las herramientas Microsoft en vez de sus asiduas Borland. Anders Hejlsberg, ex-arquitecto principal de Delphi hoy por es el de C# 3 (Omega) luego de su rotundo éxito con C# y Visual Studio.NET 2002 a su paso a Microsoft. Danny Thorpe que se quedó en su puesto recientemente fue fichado por Google para trabajar con ellos. Poco a poco han perdido a sus principales profesionales y según evalúo todo es por las malas estrategias que están tomando.&lt;/p&gt;
&lt;p&gt;Resulta ser que después de tanto años y esfuerzos en cada versión de Java Builder que lanzaban anunciaron que apoyarían al máximo posible el ambiente Eclipse. Aseguraron que seguirían dándole soporte a Java Builder y que eso no iba a cambiar la posición de la compañía, pero del dicho al hecho hay tremendo trecho.&lt;/p&gt;
&lt;p&gt;Para colmo de males, y para que se tenga una idea de lo que estamos hablando, Borland busca afanadamente una compañía que le compre todos sus productos de desarrollo (Delphi, C++ Builder, Java Builder, etc.) para centrarse solo en la metodología de desarrollo de software ALM. Es un cambio total de estrategia lo que están buscando, supongo que no dan a basto con los planes con los que intentaban ganar más adeptos, no fue suficiente con sacar una versión de un nuevo ambiente de desarrollo integrador de lenguajes de programación en 2005 -que es una pura copia de Visual Studio.NET 2003- cuando en este año y sin apenas dar tiempo a digerir esta versión lanzaron Borland Developer Studio 2006 con la misma filosofía. Lo único nuevo es ambas versiones es la posibilidad de desarrollar aplicaciones tanto para Win32 como para .NET y no en todas combinaciones de lenguajes y plataformas posibles.&lt;/p&gt;
&lt;p&gt;Resumen: pérdida de confianza total por parte de la comunidad de desarrolladores en la compañía, pérdida de gran parte del mercado de aplicaciones de desarrollo (cada día son más los que pasan a otros ambientes), pérdida de ingresos, pérdida de identidad, desaparición total de la compañía (esto no ha pasado, pero sin duda alguna sucederá pronto).&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Aspectos tener en cuenta a la hora de valorar el uso de Internet en la superación profesional</title>
      <link>/es/post/superaci%C3%B3n-personal/</link>
      <pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/superaci%C3%B3n-personal/</guid>
      
        <description>&lt;p&gt;Tengo pendiente una entrevista en la Televisión Avileña (TVA) en el programa Equilibrio de las 12 del día para conversar sobre Internet y superación profesional. Por eso es que no queriendo ir en blanco a esa entrevista decidí anotar los aspectos a mencionar en algún momento por su relevante importancia:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;La superación profesional produce un alto grado de inserción laboral.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Internet hace suponer le eliminación de las barreras de movilidad geográfica, horarios fijos, y usar materiales de formación efectivos con bastante calidad didáctica.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Internet ha ayudado a mitigar la marginación de la mujer al permitir acceso a la misma información tanto a hombre como a mujeres, sin discriminación de sexo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Si bien el 30% de las cuentas de Internet pertenecen a mujeres, cosa que no es mucho todavía, poco a poco crece y se hace más notable su presencia en la red.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Los usuarios de Internet poseen una gran cultura informacional y son capaces de crear su propio conocimiento sin ningún intermediario.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resultado de búsquedas en Internet de estos términos (según Google):&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Superación Profesional 1 890 000
Internet 4 470 000 000
Superación Profesional por Internet 652 000&lt;/p&gt;
&lt;p&gt;Para concluir nada más cierto que esta cita:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;El rápido avance de la ciencia genera nuevas disciplinas que obligan a tener una visión futurista&amp;rdquo;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>La elegancia de la programación</title>
      <link>/es/post/programaci%C3%B3n-elegante/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/programaci%C3%B3n-elegante/</guid>
      
        <description>&lt;p&gt;Si está pensando que este artículo versa sobre un sistema para vestir o ver mejor está totalmente equivocado, veremos elegancia, pero en este caso del código escrito en un lenguaje de programación. Hay quienes piensan que eso no es necesario, que el código es obvio independientemente de su estructura. Craso error, es muy, pero muy importante escribir código de una forma estructurada.&lt;/p&gt;
&lt;p&gt;Es verdad que existen herramientas formateadoras de códigos llamadas &amp;ldquo;Identadores&amp;rdquo; como DelForEx para Delphi que una vez escrito el código en la más absoluta oscuridad estructural posible y con apenas presionar una combinación de teclas es capaz de estructurarlo y quedar como un &amp;ldquo;pincel&amp;rdquo; (con opciones de personalizar todos los parámetros posibles); pero esta no es la cuestión, no se equivocó el que dijo que el hábito hace al monje.&lt;/p&gt;
&lt;p&gt;Es imprescindible interiorizar desde temprano la necesidad de escribir organizadamente el código, para ello debe comenzarse imitando la forma de hacerlo de algún profesor o compañero y luego al ir tomando experiencia adaptarlo poco a poco a nuestros gustos hasta contar con el nuestro propio al paso de los años. Esto llega sin apenas darnos cuenta de que pasó, el día que menos se lo imagina nos sorprendemos escribiendo rutinas rutinariamente (valga la redundancia).&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>No basta con solo construir</title>
      <link>/es/post/solo-desplegar-no-basta/</link>
      <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/solo-desplegar-no-basta/</guid>
      
        <description>&lt;p&gt;La experiencia nos ha mostrado que la creación de un sitio web debe partir de una planeación, seguido por una construcción del sitio y posteriormente ejecutar un proceso de medición para garantizar que los resultados se cumplan. Sin embargo, en la práctica, tal vez por parecer muy fácil su construcción, o por la poca disponibilidad de tiempo se arranca por la construcción, obviando la planeación e impidiendo la medición.&lt;/p&gt;
&lt;p&gt;La tecnología de Internet y en especial la tecnología web hace muy fácil la publicación de una aplicación, por lo que la planeación nos parece trivial. Tal vez esto sea válido para un sitio personal, pero cuando se trata de respaldar las estrategias del negocio, y en ocasiones el sitio web ES la estrategia competitiva mas importante, no se puede construir sin planear.&lt;/p&gt;
&lt;p&gt;La planeación cubre aspectos fundamentales del sitio como la funcionalidad que se quiere manejar para los diferentes públicos que accederán al portal. Hay una funcionalidad especificada en el qué, y otra que debe cubrir el cómo (la técnica). En otras palabras, se debe estipular lo que podrá hacer un usuario en el portal, y también como se implementará desde el punto de vista técnico para que se pueda realizar. Esta funcionalidad se desprende entonces en unos documentos que especifican la construcción de software que se requiere, y el diseño de la parte gráfica del sitio.&lt;/p&gt;
&lt;p&gt;También se debe desprender de la planeación la estrategia para garantizar que el portal llegará como queremos que llegue a los diferentes públicos objetivo. Si es para nuestros proveedores, por ejemplo, bastará con hacer una campaña de expectativa a través de una comunicación física, y luego implementar un procedimiento que obligue a la utilización del portal para efectuar las transacciones.&lt;/p&gt;
&lt;p&gt;Si el portal es para el público en general, como puede aplicar para una tienda virtual, se requiere establecer una campaña de mercadeo que permita llegar por los medios tradicionales a todo el público objetivo, y un plan de fidelización que promueva la compra repetitiva. Ninguno de estos ejemplos que he colocado es tarea fácil, y su dificultad aumenta en la medida en que haya menos tiempo para desarrollarla.&lt;/p&gt;
&lt;p&gt;Sin planeación, tampoco se tienen parámetros claros contra los cuales se pueda medir entonces el resultado del esfuerzo. Pero suponiendo que de alguna manera podamos censar que el resultado es menor al deseado, efectuar las tareas de planeación una vez desarrollado el portal es mucho más difícil y puede inclusive obligar a cambios en el portal y hasta un rediseño total.&lt;/p&gt;
&lt;p&gt;Quedaba un factor por analizar, y es el de la generación de contenido para el portal. Es imperante que haya una estrategia al interior de la empresa para garantizar que el contenido del mismo es acorde con las necesidades de los públicos. Si tenemos un catálogo de productos, se deberá actualizar los precios, agregar y eliminar productos, y demás funciones requeridas. Si se van a efectuar pagos, habrá que conciliar las cuentas y tener como proveer al cliente consulta sobre el estado de su pedido. Si es un sitio de contenido, habrá que manejar la imagen y el texto en forma ágil y oportuna.&lt;/p&gt;
&lt;p&gt;Estas actividades no se prevén en la construcción. Simplemente se construye y se coloca al aire, para ver que, al cabo del tiempo, y sin importar el monto de la inversión, el sitio no tuvo ningún impacto positivo y, por el contrario, podría afectar negativamente a la empresa.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Objetos ‘duros’ y ‘blandos’</title>
      <link>/es/post/objetos-duros-objetos-blandos/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/objetos-duros-objetos-blandos/</guid>
      
        <description>&lt;p&gt;Hace unos días cuando les aclaraba unas dudas a unos estudiantes hice alusión a dos tipos de objetos tal vez no muy &amp;ldquo;difundidos&amp;rdquo; (al menos por la terminología): &amp;ldquo;objetos duros&amp;rdquo; y &amp;ldquo;objetos blandos&amp;rdquo;. Unos minutos después se me acercó un profesor muy estimado por mí a hacerme la pregunta de qué significaba en realidad aquello de &amp;ldquo;objetos duros&amp;rdquo; y &amp;ldquo;objetos blandos&amp;rdquo; y me aconsejó (en un marcado tono jodedor) que me cuidara de la dureza de los mismos no fuera a ser que alguno se escapara de la computadora y me golpeara.&lt;/p&gt;
&lt;p&gt;Hasta ahí la broma, pero considero necesario aclarar los términos. Esa propiedad atribuida a los objetos en general tiene su origen en mi época de estudiante universitario mi tutor nos diferenciaba los objetos construidos en ambientes de desarrollo como Borland Delphi, Microsoft Visual Studio (C++, J++), etc. y los construidos con lenguajes scripts (JavaScript, PHP, Phyton, etc.) como objetos &amp;ldquo;duros&amp;rdquo; y &amp;ldquo;blandos&amp;rdquo; respectivamente.&lt;/p&gt;
&lt;p&gt;Una vez aclarado su origen les comento que siguió utilizándose por los miembros del grupo de investigación y en este momento todavía se usa. Su significado no había sido cuestionado, pero nunca es tarde para definiciones formales. Cuando se construyen aplicaciones sobre la arquitectura N-capas (donde es muy común tener objetos en las páginas del servidor) es bueno tener una diferenciación entre los objetos de la capa intermedia (objetos del negocio o &amp;ldquo;duros&amp;rdquo;) y los encargados de guardar información proveniente de la base de datos (objetos &amp;ldquo;blandos&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;Espero que, si no se extiende esta terminología, al menos que los lectores de mi blog me comprendan una vez que me oigan hablando de &amp;ldquo;objetos duros&amp;rdquo; y &amp;ldquo;objetos blandos&amp;rdquo;. Y para mi amigo que no se preocupe que no va a tener que visitarme en un hospital por el golpe de un objeto.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Encapsulamiento vs. Código Abierto</title>
      <link>/es/post/encapsulamiento-vs-c%C3%B3digo-abierto/</link>
      <pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/encapsulamiento-vs-c%C3%B3digo-abierto/</guid>
      
        <description>&lt;p&gt;No es de un partido de béisbol ni de una pelea de boxeo de lo que se trata este artículo sino de una duda que quisiera compartir con ustedes. Ante todo, quiero aclarar que no tengo nada en contra del Código Abierto (OS del inglés Open Source) a pesar de ser un fiel defensor de los productos Microsoft.&lt;/p&gt;
&lt;p&gt;Precisamente fue Bill Gates el que en un comunicado a la comunidad de usuarios y desarrolladores de software lanza un llamado a la reflexión sobre la &amp;ldquo;piratería&amp;rdquo; iniciando así el fenómeno de licenciamiento de software. Las respuestas no se hicieron esperar y enseguida se crearon movimientos contrarios a esta política con ligeras diferencias entre ellos, manteniendo como divisa que el conocimiento era de todos. Ejemplos tenemos a BSD, GNU y OS que es el que nos ataña.&lt;/p&gt;
&lt;p&gt;Dentro de sus características nos referiremos a la que precisamente le da nombre, la que permite que los productos que se comercialicen bajo esta licencia vayan acompañados de su código fuente. Ahora bien, por otra parte, tenemos al encapsulamiento que no es más que un mecanismo que permite a los diseñadores de tipos de datos determinar qué miembros de los tipos creen pueden ser utilizados por otros programadores y cuáles no.&lt;/p&gt;
&lt;p&gt;Entonces tenemos a los que por una parte pregonan que el código fuente es de domino público mientras que por otra encapsulan sus tipos tanto como pueden. ¿No creen que por absurda que parezca existe una paradoja en lo antes planteado?&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>¿Quién es quién en los profesionales de la computación?</title>
      <link>/es/post/profesionales-de-la-computaci%C3%B3n/</link>
      <pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/profesionales-de-la-computaci%C3%B3n/</guid>
      
        <description>&lt;p&gt;No les miento si les cuento que durante muchos años viví engañado. Desde antes de entrar a estudiar la carrera de &amp;ldquo;Licenciatura en Ciencia de la Computación&amp;rdquo; (Cibernética, como todos la conocen) en la Universidad Central &amp;ldquo;Marta Abreu&amp;rdquo; de Las Villas, pensaba que los cibernéticos eran los que &amp;ldquo;diseñaban&amp;rdquo; los productos informáticos debido a sus conocimientos más profundos en materias de computación y que luego los informáticos se encargaban de &amp;ldquo;implementarlos&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Dejando a un lado los significados del diseño y la implementación en un proceso de desarrollo de software organizado y tomándolo como la más simple de sus acepciones. El diseño es la planificación ordenada del producto desde un punto de vista arquitectural y la implementación como la codificación de las especificaciones funcionales y no funcionales.&lt;/p&gt;
&lt;p&gt;¡Qué lejos estaba de la verdad! En la carrera nunca se mencionó el tema y si no es por el roce que sostuvimos durante un curso escolar completo con los estudiantes de Ingeniería Informática (la otra carrera) de todas las universidades del país nunca hubiésemos aclarado nuestras dudas.&lt;/p&gt;
&lt;p&gt;Lo gracioso del asunto es que al compartir estas ideas con ellos me aseguraron que ellos también pensaban así solo que al revés. Los informáticos diseñaban los productos y los cibernéticos los implementaban. ¡Qué discusiones se formaban!&lt;/p&gt;
&lt;p&gt;Tanto los cibernéticos como los informáticos diseñan e implementan sistemas informáticos, la diferencia radica en el tipo de producto informático que se diseña e implementa. Mientras los segundos lo hacen con sistemas informáticos de gestión empresarial; los primeros se dedican a las herramientas y tecnologías sobre las cuales se basan los informáticos.&lt;/p&gt;
&lt;p&gt;Es cierto que el límite entre una profesión y otra es muy difuso sobre todo en nuestro país donde los puestos laborales hacen que ambos profesionales ejecuten las mismas tareas. Tal vez donde se vea un poco más las diferencias sea en las universidades donde se tengan las dos carreras a la vez, hasta ahora la Universidad de Oriente y pronto la Universidad Central de Las Villas lo experimentará.&lt;/p&gt;
&lt;p&gt;Fueron varias las definiciones de uno y de otro bando las que logramos oír. A continuación, reproducimos una de las más frecuentes:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&amp;hellip;Informático es aquel profesional que basado en los principios de la cibernética logra construir soluciones informáticas a los problemas comunes de la sociedad&amp;hellip;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Otra que, aunque es más general, es válida colocar en esta redacción es:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&amp;hellip;La diferencia entre un ingeniero y un licenciado radica en que el ingeniero hace y luego piensa mientras que el licenciado piensa y luego hace&amp;hellip;&amp;rdquo;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>¿Cibernéticos como Ingenieros?</title>
      <link>/es/post/cibern%C3%A9ticos-como-ingenieros/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/cibern%C3%A9ticos-como-ingenieros/</guid>
      
        <description>&lt;p&gt;La pregunta que da título a esta redacción está muy acorde a las carreras universitarias que se cursan un Cuba: &amp;ldquo;Ciencia de la Computación&amp;rdquo; (más conocida por &amp;ldquo;Cibernética&amp;rdquo;) e &amp;ldquo;Informática&amp;rdquo;. La primera es una licenciatura mientras que la segunda es una ingeniería.&lt;/p&gt;
&lt;p&gt;Si bien la Ingeniería Informática se ve mucho más ligada a la producción de software de gestión empresarial, no es menos cierto que existe una rama de la ingeniería que la computación no podía dejar de hacer uso de ella: la Ingeniería Inversa.&lt;/p&gt;
&lt;p&gt;Como su nombre bien lo indica esta ingeniería es la encargada de obtener los códigos fuentes de los programas a partir de las aplicaciones en código de máquina.
Ahora bien, ¿Qué tiene que ver una cosa con otra? Pues que los cibernéticos, hasta ahora, han sido la mayoría de los que se han dedicado a esta ingeniería en mi muy modesta experiencia.&lt;/p&gt;
&lt;p&gt;¿No les parece algo contradictorio? Tal vez esto tenga que ver con un próximo aporte que pienso redactar.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Validación en el cliente o en el servidor: ¿Llegó .NET? ¡Se acabaron las preocupaciones!</title>
      <link>/es/post/validaci%C3%B3n-de-datos/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/validaci%C3%B3n-de-datos/</guid>
      
        <description>&lt;p&gt;Desde los tiempos del inicio del protocolo HTTP (¿Quién iba a imaginar que, a solo 12 años, alguien se refiriera a eso con tal antigüedad?) y el ansiado carácter dinámico que poco a poco se fue haciendo más y más necesario en el mismo; la validación de los datos provenientes del cliente se hizo una necesidad mayor cada vez más.&lt;/p&gt;
&lt;p&gt;¿Cuántas veces introducimos código HTML en los campos que se nos pedían en un formulario? ¿Nunca probaron la respuesta del sistema ante la introducción de una consulta a la base de datos en un campo de un formulario? Como por ejemplo: &amp;ldquo;;DROP ALL DATABASE&amp;rdquo; o algo similar en dependencia del SQL que se maneje -el punto y coma &amp;ldquo;;&amp;rdquo; lo que le dice al sistema es que la consulta se que termina ahí y en adelante hay otra y entonces cuando se trataba de insertar el valor en la base de datos lo que pasaba era que se truncaba el INSERT y se ejecutaba el DROP y por consiguiente sus devastadoras consecuencias (OJO: Todavía hay sistemas vulnerables a este tipo de código malicioso, nunca digan que fue aquí donde lo aprendieron).&lt;/p&gt;
&lt;p&gt;Para evitar cosas como estas se realizan (incluso hoy en la actualidad) validaciones en el servidor donde se validaban los datos. Esto por supuesto trae aparejado una ralentización del sistema producto del tráfico en la red; cosa que puede dar al traste con la buena explotación del sistema debido a sus bajas prestaciones en dependencia de la configuración de la red.&lt;/p&gt;
&lt;p&gt;En este caso también caían las restricciones propias de los sistemas en cuanto a obligar a sus usuarios a introducir determinados campos de los formularios y al olvido de los clientes de esta restricción.&lt;/p&gt;
&lt;p&gt;Para todo esto se comenzó a hacer las validaciones en el cliente, es decir en el navegador web mediante la característica que poseen casi todos de brindar una interface de su documento mediante la programación en un lenguaje de secuencia de comandos (generalmente JavaScript). Esto no fue obstáculo para lo usuarios más avanzados pues comenzaron a salvar las páginas en sus computadoras para modificar los códigos fuentes eliminando dichas validaciones. Una vez introducidos los datos eran enviados al servidor donde eran procesados y de nuevo caían los sistemas.&lt;/p&gt;
&lt;p&gt;Si bien es verdad que la filosofía de validaciones no ha cambiado con la introducción de modernas tecnologías de programación como lo constituye la plataforma .NET de Microsoft; es verdad también que el código a escribir se ha minimizado a un extremo que prácticamente es cero la cantidad de líneas que hay que escribir, sobre todo si se hace uso de las facilidades de herramientas RAD como el Visual Studio .NET.&lt;/p&gt;
&lt;p&gt;Basta con arrastrar y soltar en nuestro formulario algunos controles y configurar, si acaso, un par de propiedades de los mimos para lograr que el sistema valide los datos tanto en el cliente como en el servidor en caso de que sea necesario. &amp;ldquo;RequiredFieldValidator&amp;rdquo; como su nombre bien lo indica hace que el control que se convierta de obligatoriedad la introducción de datos en el control que tiene asociado.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;RangeFieldValidator&amp;rdquo; es otro control de este tipo. Por si los que vienen con la biblioteca de clases de la plataforma (.NET Framework) no fueran suficientes la misma posee una clase para que se pueda heredar de ella e implementar nosotros mismos nuestros propios validadores respondiendo a las restricciones propias del sistema a implementar.&lt;/p&gt;
&lt;p&gt;Evalúe las posibilidades que brindan los validadores de .NET a la seguridad de aplicaciones web y utilícelos cuando los necesite para que vea en la práctica lo que decimos.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Apuntes sobre la importancia de la Ingeniería de Software</title>
      <link>/es/post/apuntes-ingenier%C3%ADa-software/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/apuntes-ingenier%C3%ADa-software/</guid>
      
        <description>&lt;p&gt;Cuando comencé la planificación de la asignatura: &amp;ldquo;Programación IV&amp;rdquo; vi que entre los temas que había que tratar estaba la Ingeniería de Software. Las dudas enseguida comenzaron a darme vueltas en la cabeza del por qué insertar ese tema aquí si justo el próximo semestre recibirían la asignatura: &amp;ldquo;Ingeniería de Software I&amp;rdquo; que partía desde cero. Junto a esto me sugirieron que tratara la importancia de esta materia apoyándome en el libro: &amp;ldquo;Software Engineering Project Management&amp;rdquo; donde de manera muy somera inducen a pensar en ella. Como colofón a las razones que me hicieron escribir estas notas fue la ayuda que me solicitó una alumna para que le prestara los apuntes que había recopilado hasta el momento; así que me di la tarea de darle forma para que sirviera de material de consulta.&lt;/p&gt;
&lt;p&gt;Un ejemplo clásico de lo que puede constituir un buen diseño de software fue lo que sucedió con el sistema automatizado de transportación de equipajes del nuevo aeropuerto internacional de Denver que reunía, entre otras, estas características:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 veces el tamaño de Manhattan.&lt;/li&gt;
&lt;li&gt;Capacidad para aterrizar tres jets a la vez en mal tiempo.&lt;/li&gt;
&lt;li&gt;21 millas de pista de acero para equipajes.&lt;/li&gt;
&lt;li&gt;100 computadoras en red.&lt;/li&gt;
&lt;li&gt;5000 ojos electrónicos.&lt;/li&gt;
&lt;li&gt;56 escáneres de códigos de barra.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Inicialmente planificado para ser desarrollado en nueve meses una vez llegado su fecha límite en Septiembre, fue pospuesto para Diciembre, de ahí para Marzo, luego para Mayo y después para Junio. Ya el Junio este proyecto estaba costando alrededor de 1.1 millones de dólares diarios. El proyecto fue suspendido cuando las pérdidas superaron los 193 millones de dólares. Lo que se pensó fuese el sistema de transportación de equipajes más avanzado de la historia, se convirtió en un gran fracaso por cuestiones de desarrollo de software.&lt;/p&gt;
&lt;p&gt;Ejemplos como este son muchos los que día a día nos topamos a tal punto que de cada seis nuevos grandes proyectos puestos en operación, otros dos son cancelados. Que si le agregásemos que la mitad de los proyectos se cancelan sin haberse puesto en operación y que las tres cuartas partes de los grandes proyectos funcionan mal, es decir, que no cumplen con las especificaciones; vemos entonces que el desarrollo de proyectos informáticos no está nada bien que digamos y que hay que poner en marchas estrategias que ayuden a contrarrestar este fenómeno.&lt;/p&gt;
&lt;p&gt;El software si bien comenzó a producirse solo para las computadoras ya hoy en día es difícil encontrarse un equipo electrodoméstico que no tenga incorporado algunas líneas de códigos. Incluso en aquellos que pueden poner en riesgo la vida humana. A continuación, una tabla con algunos equipos y una medida del código que incorpora:&lt;/p&gt;
&lt;p&gt;Televisión &amp;mdash;&amp;gt; 500Kb de código
Depiladora &amp;mdash;&amp;gt; 2Kb de código
Trenes &amp;mdash;&amp;gt; 30000 líneas de código&lt;/p&gt;
&lt;p&gt;Un fallo en estos softwares, por mínimo que sea, puede traer consecuencias desastrosas.&lt;/p&gt;
&lt;p&gt;Un grupo consultor de IBM encuestó a 24 compañías que desarrollan grandes proyectos de software arrojando que el 55% de los proyectos terminan costando más que lo planificado, el 68% sobrepasan el tiempo límite de entrega y el 88% son substancialmente rediseñados. Otras razones más para comenzar a &amp;ldquo;pensar distinto&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Por suerte no todo es malo y no puede verse como un caos (sino como algo que está cambiando para bien y que hizo falta para darnos cuenta). La industria y la academia (lo práctico y lo teórico) han dado pasos significativos en todo este meollo con el confeccionamiento de CMM y otros estándares del desarrollo de software como es el ISO.&lt;/p&gt;
&lt;p&gt;En cuanto a CMM tenemos que el 75% de las compañías productoras de software son Nivel 1; el 24% tienen Nivel 2 ó 3 (ejemplos: NASA y USAF); mientras que el solo el 1% posee Nivel 4 ó 5. Chile es el único país latinoamericanos con una compañía de Nivel 5. El estándar ISO es mucho más fácil de obtener pues está diseñado para cualquier proceso productivo mientras que CMM solo para software, el estándar ISO es equivalente a CMM Nivel 3.&lt;/p&gt;
&lt;p&gt;La intención de este artículo fue hacerlo reflexionar un poco en el tema de la Ingeniería de Software comprendiendo su importancia derivada de ejemplos y estudios realizados en el campo del desarrollo de software. Ahora le toca a usted sacar sus propias conclusiones a la hora de llevar a cabo un proyecto.&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
