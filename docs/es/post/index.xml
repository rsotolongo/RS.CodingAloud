<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Programando en voz alta</title>
    <link>/es/post/</link>
    <description>Recent content in Posts on Programando en voz alta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Mon, 15 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/es/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Generando clientes de Swagger/OpenAPI</title>
      <link>/es/post/generating-swagger-openapi-clients/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/generating-swagger-openapi-clients/</guid>
      <description>Código fuente de apoyo disponible en GitHub
Recientemente, estaba desarrollando una aplicación web .NET Core que necesita consumir una API desarrollada hace unos años usando ASP.NET WebAPI. Afortunadamente, esa API tenía Swagger integrado, así que pensé que podía ahorrar tiempo al no crear manualmente los instrumentos necesarios para las llamadas a la API (DTO, cliente, etc.) en su lugar podría utilizar la función &amp;ldquo;Servicios Conectados&amp;rdquo; de Visual Studio.
Me llevé una gran sorpresa que me inspiró a compartir la experiencia y la solución en este post.</description>
    </item>
    
    <item>
      <title>Firmando ensamblados</title>
      <link>/es/post/signing-assemblies/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/signing-assemblies/</guid>
      <description>Código fuente de apoyo disponible en GitHub
.NET Core No todos los clientes requieren firmar los ensamblados de sus aplicaciones, pero cuando es necesario, la tarea no es tan fácil como cabría esperar.
En el caso de las aplicaciones .NET Core, podemos lograr esto simplemente editando el archivo del proyecto (.csproj) agregando el siguiente código:
1 2 3  &amp;lt;Target Name=&amp;#34;BuildSigning&amp;#34; AfterTargets=&amp;#34;AfterBuild&amp;#34;&amp;gt; &amp;lt;Exec Command=&amp;#34;SIGNING_COMMAND&amp;#34; /&amp;gt; &amp;lt;/Target&amp;gt;   Como ejemplo, SIGNING_COMMAND podría ser:</description>
    </item>
    
    <item>
      <title>Generando certificados de firma</title>
      <link>/es/post/generating-signature-certificates/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/generating-signature-certificates/</guid>
      <description>Código fuente de apoyo disponible en GitHub
A veces, los ensamblados (ejecutables y bibliotecas) deben estar firmados y no tenemos un certificado disponible con fines de prueba. En este post pretendo mostrar cómo generar un certificado para firmar ensamblados.
Primero, necesitamos instalar OpenSSL que podemos lograr siguiendo los pasos que se especifican en el siguiente enlace:
Instalación de OpenSSL en Windows 10 y actualización de PATH
En segundo lugar, creemos un archivo de secuencia de comandos por lotes llamado: &amp;ldquo;generateCertificate.</description>
    </item>
    
    <item>
      <title>Desplegando paquetes NuGet</title>
      <link>/es/post/deploying-nuget-packages/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/deploying-nuget-packages/</guid>
      <description>Código fuente de apoyo disponible en GitHub
En una publicación anterior vimos cómo: &amp;ldquo;Crear paquetes NuGet&amp;rdquo; pero el paso de despliegue aún era un proceso manual. Intentemos automatizar esto. La figura 1 muestra cómo generar un paquete NuGet para un proyecto de .NET Core (similar al enfoque mostrado anteriormente) utilizando las propiedades del proyecto.
Figura 1: &amp;ldquo;Creando un paquete NuGet&amp;rdquo;.
Esto agrega un par de líneas al archivo del proyecto (.</description>
    </item>
    
    <item>
      <title>Creando paquetes NuGet</title>
      <link>/es/post/creando-paquetes-nuget/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/creando-paquetes-nuget/</guid>
      <description>Últimamente he estado involucrado en la creación de varios paquetes NuGet útiles para algunos portales que se están siendo desarrollando. Quiero compartir mis conocimientos en este tema.
Si estuviéramos desarrollando bibliotecas para .NET Core o .NET Standard, la vida sería fácil, como muestra La figura 1 a La figura 8.
Figura 1: &amp;ldquo;Creación de una nueva biblioteca de .NET Core&amp;rdquo;.
Figura 2: “Código predeterminado”.
Figura 3: &amp;ldquo;Resultados de la primera compilación&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Creando y desplegando aplicaciones usando Octopus</title>
      <link>/es/post/usando-octopus/</link>
      <pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/usando-octopus/</guid>
      <description>Código fuente de apoyo disponible en GitHub
Desde hace un tiempo quería compartir mis experiencias automatizando los despliegues de productos con Octopus desde Visual Studio. Nuevamente, hagámoslo con un ejemplo.
Como no podía ser de otra manera, La figura 1 muestra el primer paquete que debes agregar a tu proyecto para poder crear paquetes Octopus listos para ser desplegados: &amp;ldquo;OctoPack&amp;rdquo;. La última versión del paquete disponible en el momento de este tutorial era la &amp;ldquo;3.</description>
    </item>
    
    <item>
      <title>Estilizando códigos usando StyleCop</title>
      <link>/es/post/estilo-de-c%C3%B3digo-usando-stylecop/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/estilo-de-c%C3%B3digo-usando-stylecop/</guid>
      <description>Un colega me pidió que compartiera mi experiencia programando con ReSharper y, una vez que se enteró de que no uso ReSharper, sintió aún más curiosidad por saber cómo escribo los códigos fuentes. Quien me conoce sabe que me encantan los paquetes NuGet y estar actualizado constantemente, por eso encontré un paquete muy útil que instalo en todos mis proyectos apenas los inicio.
StyleCop.MSBuild
StyleCop solía ser una aplicación independiente con integración con Visual Studio, pero eso cambió hace un tiempo.</description>
    </item>
    
    <item>
      <title>Bienvenida</title>
      <link>/es/post/bienvenida/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/bienvenida/</guid>
      <description>Les doy la bienvenida oficial a mi blog profesional, intentaré escribir frecuentemente sobre tecnologías de desarrollo, lenguajes de programación, estructuras de datos, algoritmos, entre otros temas vinculados con este increíble mundo tecnológico expresando siempre mis opiniones personales.
Me decidí gracias a que sentí la necesidad imperiosa de escribir luego de acumular experiencia desarrollando software y constantemente explicar una y otra vez los conceptos, enfoques, y soluciones aplicados; unido a la recomendación de Scott Hanselman de escribir un artículo de todo aquello que no pueda ser explicado en seis oraciones.</description>
    </item>
    
    <item>
      <title>Memorias</title>
      <link>/es/post/memorias/</link>
      <pubDate>Thu, 31 Dec 2020 23:59:00 +0000</pubDate>
      
      <guid>/es/post/memorias/</guid>
      <description>Esta primera entrada es para listar todos los artículos previamente publicados en un antiguo blog que inicié en el 2006 cuando era profesor de la Universidad de Ciego de Ávila. Volviendo a leerlos, noto mucha ingenuidad, e imprecisiones pero quiero recordar que en aquel entonces mi acceso a Internet era muy limitado y mi experiencia profesional apenas comenzaba.
Creo que hay muchas cosas que siguen siendo válidas hoy en día y pueden servir de ayuda todavía.</description>
    </item>
    
    <item>
      <title>Recuperar XML desde Delphi</title>
      <link>/es/post/recuperaci%C3%B3n-de-xml/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/recuperaci%C3%B3n-de-xml/</guid>
      <description>En un artículo anterior vimos una solución a la generación de XML (Lenguaje de Marcas Extendido, siglas en inglés) desde el ambiente de desarrollo Borland Delphi; en este veremos como podemos capturar y utilizar dicho XML para otros usos.
Para ello nos remitiremos a la misma agencia noticiosa deportiva en la cual nos basamos anteriormente, donde se pretendía cubrir las diferentes competiciones de un evento enviando las noticias y resultados a través de una aplicación diseñada por sus programadores.</description>
    </item>
    
    <item>
      <title>Generar XML desde Delphi</title>
      <link>/es/post/generaci%C3%B3n-de-xml/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/generaci%C3%B3n-de-xml/</guid>
      <description>En números anteriores de esta revista salió un artículo acerca de cómo generar XML (Lenguaje de Marcas Extendido –siglas en inglés) proveniente de una forma de HTML (Lenguaje de Marcado de Hipertexto –siglas en inglés) desde ASP (Active Server Pages) con la ayuda del objeto del sistema de ficheros (FileSystemObject). En este artículo veremos cómo hacerlo desde Delphi aprovechando algunas de las incontables ventajas de este ambiente de desarrollo.
Recordemos primeramente que XML es un subconjunto de SGML (Lenguaje de Marcado Generalizado Estándar) y más que un simple lenguaje de marcas como su nombre sugiere es un meta-lenguaje que nos permite definir lenguajes de marcado adecuados a usos determinados y que está llamado a ser el nuevo ASCII debido a su fácil confección, transmisión y comprensión.</description>
    </item>
    
    <item>
      <title>Algunas consideraciones de Implementación</title>
      <link>/es/post/consideraciones-de-implementaci%C3%B3n/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/consideraciones-de-implementaci%C3%B3n/</guid>
      <description>Creemos que es necesario comenzar este artículo sugiriendo la introducción de tres técnicas que, si bien no son nuevas, sí constituyen buenas prácticas dentro del desarrollo organizado de software.
El acoplamiento de módulos, la compilación, la producción de ejecutables, la generación de reportes y la creación y restauración de copias de seguridad en la producción de sistemas informáticos constituyen tareas perfectamente automatizables. Las ventajas que puede traer el uso de esta técnica están estrechamente relacionadas con el tiempo total de desarrollo de los sistemas informáticos.</description>
    </item>
    
    <item>
      <title>Algunas consideraciones de Diseño</title>
      <link>/es/post/consideraciones-de-dise%C3%B1o/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/consideraciones-de-dise%C3%B1o/</guid>
      <description>Dentro de las etapas en que se divide el ciclo de vida del desarrollo de software, el Diseño es considerada como la más importante. Se ha calculado que puede llegar a ocupar hasta un treinta y cinco por ciento del total de tiempo. Es por ello que abordaremos el tema para dar algunas consideraciones generales que siempre son válidas a tener en cuenta, sea cual sea el tipo de aplicación a desarrollar.</description>
    </item>
    
    <item>
      <title>Gobierno electrónico</title>
      <link>/es/post/gobierno-electr%C3%B3nico/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/gobierno-electr%C3%B3nico/</guid>
      <description>Con la decisión de migrar todos sus sistemas y aplicaciones a Software Libre del gobierno alemán, hace ya uno tres años, estalló este fenómeno entre los diferentes países, llegando incluso a instancias particulares de ellos. Ejemplo de ello es España donde ya algunas de sus autonomías han tomado la misma decisión, otras no. Lo cierto es que hay protestas por todo el mundo tanto de detractores como de los que piensan igual.</description>
    </item>
    
    <item>
      <title>¿Se puede confiar ciegamente en Internet?</title>
      <link>/es/post/confianza-en-internet/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/confianza-en-internet/</guid>
      <description>Internet se ha convertido poco a poco en la herramienta más útil del quehacer diario de las personas para un sin número de tareas que van desde la investigación científica hasta las compras y el ocio. Es por ello que constituye una fuente invaluable de conocimientos, pero ojo, no todo lo que brilla es oro.
En varias ocasiones he leído como se descubren cosas insólitas que suceden en Internet, como la publicación de cómo confeccionar artefactos explosivos o de cómo se ponen de acuerdo miembros de sectas para suicidarse masivamente, etc.</description>
    </item>
    
    <item>
      <title>ISFUROS 2006</title>
      <link>/es/post/isfuros-2006/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/isfuros-2006/</guid>
      <description>He estado tan ocupado en tareas aledañas que poco a poco fue pasando el tiempo y ni cuenta me di de que llevaba meses sin escribir nada, luego caí en un vacío profesional que no me incitaba a redactar nada hasta hoy mismo que luego de participar en el ISFUROS me llamé yo mismo a reflexionar y no dejar pasar inadvertido el evento.
El International International Symposium on Fuzzy and Rough Sets (ISFUROS) fue un evento que se desarrolló en la UCLV del 4 al 6 de Diciembre del 2006.</description>
    </item>
    
    <item>
      <title>Poniéndome al día</title>
      <link>/es/post/poni%C3%A9ndonos-al-d%C3%ADa/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/poni%C3%A9ndonos-al-d%C3%ADa/</guid>
      <description>No voy a ponerme a relatar las vicisitudes que llevaron a que prácticamente no tenga Internet a mi disposición, porque sería aburrirlos en vano y al final lo más seguro es que no entenderían y todo quedará igual, así que para qué perder el tiempo entonces; aprovechémoslo en otras cuestiones más importantes.
Quise hacer esta breve introducción pues lo que quiero comentarles hoy se relaciona con este hecho precisamente. El pasado domingo día 3 de diciembre, vine a la Universidad temprano pues estaba de guardia todo el día y aprovecharía Internet para ponerme al día y confeccionar una serie de documentos atrasados que tenía.</description>
    </item>
    
    <item>
      <title>Amaos los unos a los otros</title>
      <link>/es/post/amaos-todos/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/amaos-todos/</guid>
      <description>Leyendo el título de este artículo pudieran pensar que se enfrentarán a un debate relacionado con la teología, pero no será así. Creo haber escrito antes algo sobre las diferencias entre profesionales de la computación y la semejanza que tienen sus discusiones con las que sostienen los creyentes con los no creyentes en Dios.
No repetiré lo que ya dije una vez, esta vez me desenvolveré en la rama de mi profesión solamente.</description>
    </item>
    
    <item>
      <title>La delgada línea entre reescribir y reutilizar código</title>
      <link>/es/post/reescribir-%C3%B3-reusar/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/reescribir-%C3%B3-reusar/</guid>
      <description>Hay veces que no nos damos cuenta de la existencia de delgadas líneas que existen entre cosas. Por otra parte, no sé por qué tenemos esa desconfianza en lo que otro hace. La reticencia al cambio es algo siempre presente en toda persona y es un mal muy difícil de arraigar, hay que ser un experto para lograr que se entiendan los cambios.
Serán por estas razones por las que nosotros los profesionales de la computación cada vez que tenemos que desarrollar una aplicación pensamos seriamente codificarla desde cero, incluso a veces lo hacemos.</description>
    </item>
    
    <item>
      <title>El futuro del Ensamblador</title>
      <link>/es/post/futuro-del-ensamblador/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/futuro-del-ensamblador/</guid>
      <description>Si difícil fue en su tiempo programar en lenguaje de máquina, difícil fue también hacerlo en ensamblador, aunque todavía haya personas que no lo quieran reconocer. El lenguaje ensamblador constituyó un paso de adelanto indudable sobre su predecesor, pero no estaba extinto de problemas.
Poco a poco fue tomando auge, pero a la vez fueron surgiendo nuevos lenguajes que se le superponían y a la vez acomodaban al programador. Esto no es más que parte de la lógica de la evolución de la programación.</description>
    </item>
    
  </channel>
</rss>
