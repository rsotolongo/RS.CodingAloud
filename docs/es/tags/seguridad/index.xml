<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>seguridad on Programando en voz alta</title>
    <link>/es/tags/seguridad/</link>
    <description>Recent content in seguridad on Programando en voz alta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Mon, 08 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/es/tags/seguridad/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Firmando ensamblados</title>
      <link>/es/post/signing-assemblies/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/signing-assemblies/</guid>
      <description>Código fuente de apoyo disponible en GitHub
.NET Core No todos los clientes requieren firmar los ensamblados de sus aplicaciones, pero cuando es necesario, la tarea no es tan fácil como cabría esperar.
En el caso de las aplicaciones .NET Core, podemos lograr esto simplemente editando el archivo del proyecto (.csproj) agregando el siguiente código:
1 2 3  &amp;lt;Target Name=&amp;#34;BuildSigning&amp;#34; AfterTargets=&amp;#34;AfterBuild&amp;#34;&amp;gt; &amp;lt;Exec Command=&amp;#34;SIGNING_COMMAND&amp;#34; /&amp;gt; &amp;lt;/Target&amp;gt;   Como ejemplo, SIGNING_COMMAND podría ser:</description>
    </item>
    
    <item>
      <title>Generando certificados de firma</title>
      <link>/es/post/generating-signature-certificates/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/es/post/generating-signature-certificates/</guid>
      <description>Código fuente de apoyo disponible en GitHub
A veces, los ensamblados (ejecutables y bibliotecas) deben estar firmados y no tenemos un certificado disponible con fines de prueba. En este post pretendo mostrar cómo generar un certificado para firmar ensamblados.
Primero, necesitamos instalar OpenSSL que podemos lograr siguiendo los pasos que se especifican en el siguiente enlace:
Instalación de OpenSSL en Windows 10 y actualización de PATH
En segundo lugar, creemos un archivo de secuencia de comandos por lotes llamado: &amp;ldquo;generateCertificate.</description>
    </item>
    
    <item>
      <title>Validación en el cliente o en el servidor: ¿Llegó .NET? ¡Se acabaron las preocupaciones!</title>
      <link>/es/post/validaci%C3%B3n-de-datos/</link>
      <pubDate>Wed, 02 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>/es/post/validaci%C3%B3n-de-datos/</guid>
      <description>Desde los tiempos del inicio del protocolo HTTP (¿Quién iba a imaginar que, a solo 12 años, alguien se refiriera a eso con tal antigüedad?) y el ansiado carácter dinámico que poco a poco se fue haciendo más y más necesario en el mismo; la validación de los datos provenientes del cliente se hizo una necesidad mayor cada vez más.
¿Cuántas veces introducimos código HTML en los campos que se nos pedían en un formulario?</description>
    </item>
    
  </channel>
</rss>
