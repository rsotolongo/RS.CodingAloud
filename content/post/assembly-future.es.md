---
title: "El futuro del Ensamblador"
date: 2020-12-17
draft: false
slug: futuro-del-ensamblador
tags: ["arquitectura"]
categories: ["Memorias"]
---
Si difícil fue en su tiempo programar en lenguaje de máquina, difícil fue también hacerlo en ensamblador, aunque todavía haya personas que no lo quieran reconocer. El lenguaje ensamblador constituyó un paso de adelanto indudable sobre su predecesor, pero no estaba extinto de problemas.

Poco a poco fue tomando auge, pero a la vez fueron surgiendo nuevos lenguajes que se le superponían y a la vez acomodaban al programador. Esto no es más que parte de la lógica de la evolución de la programación. A medida que estos nuevos lenguajes iban tomando auge, a la vez otros nuevos se desarrollaban y así sucesivamente.
Hoy por hoy hay muchos profesionales que insisten en que los proyectos desarrollados en ensamblador son mejores que los que son desarrollados en lenguajes de alto nivel (Object Pascal, Java, C#, etc.) pues consumen menos espacio en disco, memoria cuando están ejecutándose y son extremadamente veloces. En cierta manera no es menos cierto lo que plantean, pero hay elementos que no tienen en cuenta. Con los estándares de desarrollo profesional de software del momento estos argumentos pierden importancia frente a otros como son (sobre todas las cosas) el tiempo de respuesta y completitud de los proyectos.

Se hace insoportable el mantenimiento. La industria de software moderna exige cada vez más que las aplicaciones sean desarrolladas en tiempo record, cosa que es incomparable cuando se programa en ensamblador. En todos los casos me he referido a las aplicaciones empresariales tradicionales.

El ensamblador está condenado hoy en día para el desarrollo de firmware a muy bajo nivel para los dispositivos empotrados, por ejemplo: sistemas operativos para dispositivos móviles, equipos médicos, de telecomunicaciones, etc. Un buen amigo me dijo hace ya unos años que el programa que por sus características propias tuviera que implementar alguno de sus módulos en ensamblador, ese programa estaba mal diseñado; comparto con mi amigo esa verdad (si eso fue hace unos años ¿qué podremos pensar hoy?). Los Plan de Estudios "D" tiene esto muy en mente también y todo parece ser que se seguirá impartiendo conocimientos de ensamblador, pero a los niveles diferentes a los que se estaban dando.

El dilema está planteado por las características de las dos grandes plataformas de desarrollo de software actuales (Java y .NET) ninguna permite interactuar con el ensamblador, eliminándole al programador infinitas molestias. Si todo parece indicar que esto va a continuar en los próximos años entonces por qué torturarnos enseñando algo que poco a poco va a ir desapareciendo (Microsoft está llevando adelante un proyecto de un Sistema Operativo en C#).
